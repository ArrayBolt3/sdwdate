#!/usr/bin/python3 -u

## Copyright (C) 2017 - 2020 ENCRYPTED SUPPORT LP <adrelanos@riseup.net>
## See the file COPYING for copying conditions.

import sys
sys.dont_write_bytecode = True

import logging
import signal
import os
import glob
import time
from datetime import datetime
import random
from random import randint
from subprocess import Popen, call, PIPE, check_output
import subprocess
import json
import re
from shutil import rmtree
from pathlib import Path

from sdwdate.remote_times import get_time_from_servers
from sdwdate.config import read_pools
from sdwdate.timesanitycheck import timesanitycheck
from sdwdate.timesanitycheck import time_consensus_sanity_check
from sdwdate.proxy_settings import proxy_settings

from guimessages.translations import _translations

import sdnotify

os.environ['LC_TIME'] = 'C'
os.environ['TZ'] = 'UTC'
time.tzset()

n = sdnotify.SystemdNotifier()
n.notify("READY=1")
n.notify("STATUS=Starting...")


class Time_Source_Pool:
    def __init__(self, pool):
        self.url, self.comment = read_pools(pool, 'production')
        self.url_random = []
        self.already_picked_index = []
        self.failed_urls = 0
        self.done = False

    @property
    def url_range(self):
        return len(self.url)

    def allowed_failures(self):
        failure_ratio = None
        if os.path.exists('/etc/sdwdate.d/'):
            files = sorted(glob.glob('/etc/sdwdate.d/*.conf'))
            for f in files:
                with open(f) as conf:
                    lines = conf.readlines()
                for line in lines:
                    if line.startswith('MAX_FAILURE_RATIO'):
                        failure_ratio = re.search(r'=(.*)', line).group(1)
        if failure_ratio == None:
           failure_ratio = 0.34
        x = float(len(self.url))
        y = float(failure_ratio)
        z = x * y
        allowed_failures_value = int(z)
        #print("failure_ratio: " + str(failure_ratio))
        #print("x: " + str(x))
        #print("y: " + str(y))
        #print("z: " + str(z))
        #print("allowed_failures_value: " + str(allowed_failures_value))
        return allowed_failures_value


class Sdwdate:
    def __init__(self):
        self.iteration = 0
        self.number_of_pools = 3

        self.pools = [Time_Source_Pool(pool) for pool in range(self.number_of_pools)]
        ## Could get it here to prevent reading the file in sdwdate_loop for each Unreachable url.
        #self.allowed_failures = [Time_Source_Pool(pool).allowed_failures for pool in range(self.number_of_pools)]
        self.urls = []
        self.url_random = []
        self.valid_urls = []
        self.unixtimes = []
        self.pools_diff = []
        self.failed_urls = []
        self.url_errors = []

        self.median_diff_in_seconds = 0
        self.range_nanoseconds = 999999999
        self.new_diff_in_seconds = 0
        self.new_diff_in_nanoseconds = 0

        home_folder = str(Path.home())
        home_folder_split = os.path.split(Path.home())

        if home_folder_split[0] == "/home":
            ## Required for support of running as users other than sdwdate.
            sdwdate_status_files_folder = home_folder + "/sdwdate"
            ## example sdwdate_status_files_folder:
            ## /home/user/sdwdate
        else:
            ## home folder for user sdwdate is set to /run/sdwdate
            sdwdate_status_files_folder = home_folder
            ## example sdwdate_status_files_folder:
            ## /run/sdwdate

        ## Sanity test.
        sdwdate_status_files_folder_split = os.path.split(sdwdate_status_files_folder)
        if not sdwdate_status_files_folder_split[-1] == "sdwdate":
            print("ERROR: home folder does not end with /sdwdate")
            print("ERROR: home_folder_split: " + str(home_folder_split))
            print("ERROR: sdwdate_status_files_folder_split: " + str(sdwdate_status_files_folder_split))
            print("ERROR: sdwdate_status_files_folder: " + sdwdate_status_files_folder)
            reason = "home folder does not end with /sdwdate"
            exit_code = 1
            sdwdate.exit_handler(exit_code, reason)

        Path(sdwdate_status_files_folder).mkdir(parents=True, exist_ok=True)

        self.status_first_success_path = sdwdate_status_files_folder + '/first_success'
        self.status_success_path = sdwdate_status_files_folder + '/success'
        self.status_file_path = sdwdate_status_files_folder + '/status'
        self.sleep_long_file_path = sdwdate_status_files_folder + '/sleep_long'
        self.clock_jump_do_once_file = sdwdate_status_files_folder + '/clock_jump_do_once'
        ## Read by whonixcheck.
        self.msg_path = sdwdate_status_files_folder + '/msg'

        self.status = {'icon': '', 'message': ''}

        translations_path = '/usr/share/translations/sdwdate.yaml'
        translation = _translations(translations_path, 'sdwdate')
        self._ = translation.gettext

        self.proxy_ip, self.proxy_port = proxy_settings()

    def signal_sigterm_handler(self, signum, frame):
        message = sdwdate._('sigterm')
        stripped_message = sdwdate.strip_html(message)
        logger.info(stripped_message)
        reason = "signal_sigterm_handler called"
        exit_code = 143
        sdwdate.exit_handler(exit_code, reason)

    def exit_handler(self, exit_code, reason):
        n.notify("STATUS=Shutting down...")
        n.notify("WATCHDOG=1")
        n.notify("STOPPING=1")

        message = "Exiting with exit_code '" + str(exit_code) + "' because or reason '" + reason + "'."
        logger.info(message)

        icon = "error"
        message = "sdwdate stopped by user or system."
        stripped_message = sdwdate.strip_html(message)
        sdwdate.write_status(icon, message)

        sdwdate.kill_sclockadj()
        sdwdate.kill_sleep_process()

        ## use missing_ok=True in python 3.8
        if os.path.isfile(sdwdate.sleep_long_file_path):
            os.remove(sdwdate.sleep_long_file_path)

        logger.info(stripped_message)
        sys.exit(exit_code)

    def strip_html(self, message):
        ## New line for log.
        tmp_message = re.sub('<br>', '\n', message)
        ## Strip remaining HTML.
        return re.sub('<[^<]+?>', '', tmp_message)

    def write_status(self, icon, msg):
        sdwdate.status['icon'] = icon
        sdwdate.status['message'] = msg
        try:
            with open(sdwdate.status_file_path, 'w') as f:
                json.dump(sdwdate.status, f)
                f.close()
        except:
            error_msg = "Unexpected error: " + str(sys.exc_info()[0])
            print(error_msg)
            return

        with open(sdwdate.msg_path, 'w') as msgf:
            msgf.write(msg)
            msgf.close()

    def preparation(self):
        message = ''
        previous_messsage = ''
        sdwdate = Sdwdate()
        loop_counter = 0
        loop_max = 10000
        preparation_sleep_seconds = 0
        while True:
            n.notify("WATCHDOG=1")
            if loop_counter >= loop_max:
                loop_counter = 0
            loop_counter += 1
            msg = "STATUS=Running sdwdate preparation loop. preparation_sleep_seconds: " + \
    str(preparation_sleep_seconds) + " iteration: " + str(loop_counter) + " / " + str(loop_max)
            n.notify(msg)

            ## Wait one second after first failure. Two at second failure etc.
            ## Up to a maximum of ten seconds wait between attempts.
            ## The rationale behind this is to be quick at boot time while not
            ## stressing the system.
            preparation_sleep_seconds += 1
            if preparation_sleep_seconds >= 10:
                preparation_sleep_seconds = 10

            preparation_path = '/usr/lib/helper-scripts/onion-time-pre-script'
            preparation_status = subprocess.Popen(preparation_path, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            stdout, stderr = preparation_status.communicate()
            preparation_status.kill()
            output_stdout = stdout.decode('UTF-8')
            output_stderr = stderr.decode('UTF-8')
            joint_message = output_stderr + "\n" + output_stdout

            if preparation_status.returncode == 0:
                logger.info("PREPARATION:")
                message = joint_message.strip()
                logger.info(sdwdate.strip_html(message))
                logger.info("PREPARATION RESULT: SUCCESS.")
                logger.info("\n")
                return True

            if joint_message == previous_messsage:
                ## No new message. No status changes. Therefore do not reset wait
                ## counter and wait preparation_sleep_seconds.
                #logger.info("PREPARATION RESULT: Skip showing same message.")
                time.sleep(preparation_sleep_seconds)
                continue

            previous_messsage = joint_message

            logger.info("PREPARATION:")
            message = joint_message.strip()
            logger.info(sdwdate.strip_html(joint_message))

            if preparation_status.returncode == 1:
                icon = "error"
                logger.info("PREPARATION RESULT: (known) ERROR.")
            elif preparation_status.returncode == 2:
                icon = "busy"
                logger.info("PREPARATION RESULT: WAIT.")
            else:
                icon = "error"
                logger.info("PREPARATION RESULT: (unknown) ERROR.")

            logger.info("\n")
            ## TODO: remove this once security implications are sorted.
            ## https://phabricator.whonix.org/T534#15429
            main_message = "Preparation not done yet. More more information, see: sdwdate-gui -> right click -> Open sdwdate's log"

            sdwdate.write_status(icon, main_message)

            ## Different message. Probably progress was made.
            ## More progress to be expected. Therefore reset wait counter to just
            ## wait a short time.
            preparation_sleep_seconds = 1
            time.sleep(preparation_sleep_seconds)

    @staticmethod
    def general_proxy_error(pools):
        '''
        This error occurs (at least) when Tor is not running.
        '''
        returned_error = 'connect error: Connection closed unexpectedly'
        if (pools[0] == returned_error and
                    pools[1] == returned_error and
                    pools[2] == returned_error):
            return True
        return False

    @staticmethod
    def general_timeout_error(pools):
        '''
        This error occurs (at least) when internet connection is down.
        '''
        returned_error = 'Timeout'
        if (pools[0] == returned_error and
                    pools[1] == returned_error and
                    pools[2] == returned_error):
            return True
        return False

    @staticmethod
    def check_remote(remote, stdout, stderr, comment, i):
        '''
        Check returned stdout. True if numeric.
        '''
        pool_number = str(i)
        message = "remote " + pool_number + ": " + remote
        logger.info(message)

        message = "* comment: " + comment
        logger.info(message)

        try:
            remote_unixtime = int(stdout)
            old_unixtime = (time.time())
            remote_time = (datetime.strftime(datetime.fromtimestamp(remote_unixtime),
                                                   '%Y-%m-%d %H:%M:%S'))
            time_diff = int(remote_unixtime) - int(old_unixtime)
            time_diff = str(time_diff)
        except:
            message = "* status: False"
            logger.info(message)
            message = "* stdout: " + str(stdout)
            logger.info(message)
            message = "* stderr: " + str(stderr)
            logger.info(message)
            if stdout == "sigterm":
               reason = "remote_times.py returned stdout 'sigterm'"
               exit_code = 143
               sdwdate.exit_handler(exit_code, reason)
            return False

        timesanitycheck_status, time_one, time_two, timesanitycheck_error = timesanitycheck(remote_unixtime)

        consensus_status, consensus_error, consensus_valid_after_str, consensus_valid_until_str = time_consensus_sanity_check(remote_unixtime)

        message = "* stderr: " + str(stderr)
        logger.info(message)
        message = "* remote_unixtime: " + str(remote_unixtime)
        logger.info(message)
        message = "* consensus/valid-after: " + consensus_valid_after_str
        logger.info(message)
        message = "* remote_time          : " + remote_time
        logger.info(message)
        message = "* consensus/valid-until: " + consensus_valid_until_str
        logger.info(message)
        message = "* time_diff: " + time_diff + " second(s)"
        logger.info(message)

        ## Fallback.
        remote_status = "fallback"

        if timesanitycheck_status == 'sane':
            message = "* Static Time Sanity Check: sane"
            logger.info(message)
        elif timesanitycheck_status == 'slow':
            message = "* Static Time Sanity Check: slow"
            logger.info(message)
            remote_status = "False"
        elif timesanitycheck_status == 'fast':
            message = "* Static Time Sanity Check: fast"
            logger.info(message)
            remote_status = "False"
        elif timesanitycheck_status == 'error':
            message = "* Static Time Sanity Check: error: " + timesanitycheck_error
            logger.info(message)
            remote_status = "False"

        if consensus_status == 'ok':
            message = "* Tor Consensus Time Sanity Check: sane"
            logger.info(message)
            if not remote_status == "False":
                remote_status = "True"
        elif consensus_status == 'slow':
            message = "* Tor Consensus Time Sanity Check: slow"
            logger.info(message)
            remote_status = "False"
        elif consensus_status == 'fast':
            message = "* Tor Consensus Time Sanity Check: fast"
            logger.info(message)
            remote_status = "False"
        elif consensus_status == 'error':
            message = "* Tor Consensus Time Sanity Check: error: " + consensus_error
            logger.info(message)
            remote_status = "False"

        message = "* remote_status: " + str(remote_status)
        logger.info(message)

        if remote_status == "True":
            return True
        else:
            return False


    def get_comment(self, remote):
        ''' For logging the comments, get the index of the url
            to get it from pool.comment.
        '''
        url_comment = ''
        for url in self.pools:
            try:
                url_index = url.url.index(remote)
                url_comment = url.comment[url_index]
            except ValueError:
                pass
        return url_comment

    def build_median(self):
        '''
        Get the median (not average) from the list of values.
        '''
        diffs = sorted(self.pools_diff)
        message = 'pool differences, sorted: %s' % diffs
        logger.info(message)
        self.median_diff_in_seconds = diffs[(len(diffs) // 2)]
        message = 'median time difference: %+.9f' % self.median_diff_in_seconds
        logger.info(message)

    def set_new_time(self):
        '''
        Do not set time if diff = 0.
        '''
        if self.median_diff_in_seconds == 0:
            message = 'Time difference = 0. Not setting time.'
            logger.info(message)
            return True

        status_first_success = os.path.exists(self.status_first_success_path)
        clock_jump_do = os.path.exists(self.clock_jump_do_once_file)

        if not status_first_success:
            sdwdate.set_time_using_date()
        elif clock_jump_do:
            sdwdate.set_time_using_date()
        else:
            sdwdate.run_sclockadj()

        if not status_first_success:
            f = open(sdwdate.status_first_success_path, 'w')
            f.close()
        if clock_jump_do:
            ## use missing_ok=True in python 3.8
            if os.path.isfile(sdwdate.clock_jump_do_once_file):
                os.remove(sdwdate.clock_jump_do_once_file)

        f = open(sdwdate.status_success_path, 'w')
        f.close()

    def randomize_time_config(self):
        status = False
        if not os.path.exists('/etc/sdwdate.d/'):
            return status
        files = sorted(glob.glob('/etc/sdwdate.d/*.conf'))
        for f in files:
            with open(f) as conf:
                lines = conf.readlines()
                for line in lines:
                    if line.startswith('RANDOMIZE_TIME=true'):
                        status = True
                    if line.startswith('RANDOMIZE_TIME=false'):
                        status = False
        return status

    def add_or_subtract_nanoseconds(self):
        if sdwdate.randomize_time_config():
            logger.info("Randomizing nanoseconds.")
            nanoseconds_to_add_or_subtract = randint(0, self.range_nanoseconds)
            signs = ['+', '-']
            sign = randint(0, 1)
            seconds_to_add_or_subtract = float(nanoseconds_to_add_or_subtract) / 1000000000
            if sign == 1:
               seconds_to_add_or_subtract = seconds_to_add_or_subtract * -1
            message = 'randomize             : %+.9f' % seconds_to_add_or_subtract
            logger.info(message)
        else:
            logger.info("Not randomizing nanoseconds.")
            #nanoseconds_to_add_or_subtract = 0
            seconds_to_add_or_subtract = 0

        ## Consumed by set_time_using_date.
        self.new_diff_in_seconds = self.median_diff_in_seconds + seconds_to_add_or_subtract

        ## Consumed by run_sclockadj.
        self.new_diff_in_nanoseconds = int(self.new_diff_in_seconds * 1000000000)

        message = 'new time difference   : %+.9f' % self.new_diff_in_seconds
        logger.info(message)

    def run_sclockadj(self):
        sclockad_cmd = '/usr/lib/sdwdate/sclockadj "' + str(self.new_diff_in_nanoseconds) + '"'
        message = 'Gradually adjusting the time by running sclockadj using command: %s' % sclockad_cmd
        logger.info(message)
        ## Run sclockadj in a subshell.
        self.sclockadj_process = Popen(sclockad_cmd, shell=True)
        message = 'Launched sclockadj into the background. PID: %s' % self.sclockadj_process.pid
        logger.info(message)

    def kill_sclockadj(self):
        try:
            self.sclockadj_process.kill()
            message = 'Terminated sclockadj process.'
            logger.info(message)
        except:
            message = 'sclockadj process not running, ok.'
            logger.info(message)

    def kill_sleep_process(self):
        try:
            self.sleep_process.kill()
            message = 'Terminated sleep process.'
            logger.info(message)
        except:
            message = 'sleep process not running, ok.'
            logger.info(message)

    def set_time_using_date(self):
        old_unixtime = format(time.time(), '.9f')
        message = 'old unixttime: ' + old_unixtime
        logger.info(message)

        new_unixtime = float(old_unixtime) + float(self.new_diff_in_seconds)
        new_unixtime_str = format(new_unixtime, '.9f')

        message = 'new unixtime : ' + new_unixtime_str
        logger.info(message)

        ## Set new time.
        cmd = '/bin/date --utc "+%Y-%m-%d %H:%M:%S" --set "@' + str(new_unixtime_str) + '"'
        message = 'Instantly setting the time by using command: %s' % cmd
        logger.info(message)

        bin_date_status = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = bin_date_status.communicate()
        bin_date_status.kill()
        output_stdout = stdout.decode('UTF-8')
        output_stderr = stderr.decode('UTF-8')
        joint_message = output_stdout + " " + output_stderr
        message = '/bin/date output: %s' % joint_message
        logger.info(message)

        if not bin_date_status.returncode == 0:
            message = '/bin/date returncode: %s' % str(bin_date_status.returncode)
            logger.error(message)
            reason = "bin_date_status non-zero exit code"
            exit_code = 1
            sdwdate.exit_handler(exit_code, reason)

    def sdwdate_loop(self):
        '''
        Check remotes.
        Pick a random url in each pool, check the returned stdout.
        Append valid urls if time is returned, otherwise restart a cycle
        with a new random url, until every pool has a time value.
        returns:
        icon, status, sdwdate_message_from_loop
        '''
        message = "Start fetching remote times."
        logger.info(message)

        fetching_msg = self._('fetching')
        restricted_msg = self._('restricted')

        #message = "restricted_msg: " + restricted_msg
        #logger.info(message)
        ## restricted_msg: Initial time fetching in progress...

        status_first_success = os.path.exists(self.status_first_success_path)

        if not status_first_success:
            icon = "busy"
            sdwdate.write_status(icon, restricted_msg)
            message = sdwdate.strip_html(restricted_msg)
            logger.info(message)
        else:
            icon = "success"
            sdwdate.write_status(icon, fetching_msg)
            message = sdwdate.strip_html(fetching_msg)
            logger.info(message)

        while True:
            self.iteration += 1
            message = 'Running sdwdate fetch loop. iteration: %s' % self.iteration
            logger.info(message)

            ## Clear the lists.
            self.urls[:] = []
            self.url_random[:] = []

            for pool in self.pools:
                if not pool.done:
                    pool_range = pool.url_range
                    while True:
                       url_index = random.randrange(0, pool_range)
                       #print("pool_range: " + str(pool_range))
                       if not url_index in pool.already_picked_index:
                          #print("AAA str(len(pool.already_picked_index)): " + str(len(pool.already_picked_index)))
                          pool.already_picked_index.append(url_index)
                          break
                       if len(pool.already_picked_index) >= pool_range:
                          #print("BBB str(len(pool.already_picked_index)): " + str(len(pool.already_picked_index)))
                          pool_number = self.pools.index(pool)
                          message = self._('no_valid_time') + str(pool_number) + self._('restart')
                          logger.warning(message)
                          icon = "error"
                          status = "error"
                          return icon, status, message
                       #if url_index in pool.already_picked_index:
                          #print("CCC str(len(pool.already_picked_index)): " + str(len(pool.already_picked_index)))

                    message = "pool " + str(self.pools.index(pool)) + ": pool_range: " + str(pool_range) + " url_index: " + str(url_index) + " len(pool.already_picked_index): " + str(len(pool.already_picked_index)) + " pool.already_picked_index: " + str(pool.already_picked_index)
                    logger.info(message)

                    pool.url_random.append(pool.url[url_index])
                    self.url_random.append(pool.url[url_index])

            if len(self.url_random) > 0:
                message = 'requested urls %s' % self.url_random
                logger.info(message)

                self.urls, self.list_of_stdout, self.list_of_stderr = get_time_from_servers(self.url_random,
                                                                        self.proxy_ip,
                                                                        self.proxy_port)

                if len(self.urls) == 0:
                    message = self._('no_value_returned') + self._('restart')
                    icon = "error"
                    status = "error"
                    return icon, status, message

                message = 'returned urls "%s"' % self.urls
                logger.info(message)

            else:
                message = self._('list_not_built') + self._('restart')
                icon = "error"
                status = "error"
                return icon, status, message

            for i in range(len(self.urls)):
                if self.check_remote(self.urls[i], self.list_of_stdout[i], self.list_of_stderr[i], self.get_comment(self.urls[i]), i):
                    self.valid_urls.append(self.urls[i])
                    self.unixtimes.append(self.list_of_stdout[i])
                else:
                    self.failed_urls.append(self.urls[i])
                    self.url_errors.append(self.list_of_stdout[i])

            if self.iteration >= 3:
               if len(self.list_of_stdout) >= 3:
                     if self.general_proxy_error(self.list_of_stdout):
                        message = self._('general_proxy_error')
                        icon = "error"
                        status = "error"
                        return icon, status, message
                     if self.general_timeout_error(self.list_of_stdout):
                        message = self._('general_timeout_error')
                        icon = "error"
                        status = "error"
                        return icon, status, message

            for i in range(len(self.urls)):
               for pool in self.pools:
                  if self.urls[i] in pool.url_random:
                     failures_allowed_per_pool = pool.allowed_failures()
                     message  = ''
                     message += "pool "
                     message += str(self.pools.index(pool))
                     message += ":"
                     message += " failed_urls: "
                     message += str(len(self.failed_urls))
                     message += " allowed_failures: "
                     message += str(failures_allowed_per_pool)
                     logger.info(message)
                     if len(self.failed_urls) > failures_allowed_per_pool:
                        message = "Maximum allowed number of failures. Giving up."
                        icon = "error"
                        status = "error"
                        return icon, status, message

            old_unixtime = (time.time())

            for pool in self.pools:
                if not pool.done:
                    for url in pool.url_random:
                        pool.done = url in self.valid_urls
                        if pool.done:
                            ## Values are returned randomly. Get the index of the url.
                            index = self.valid_urls.index(url)
                            ## pool matching web time
                            web_unixtime = int(self.unixtimes[index])

                            web_time = (datetime.strftime(datetime.fromtimestamp(web_unixtime),
                                                              '%a %b %d %H:%M:%S UTC %Y'))
                            pool_diff = int(web_unixtime) - int(old_unixtime)
                            self.pools_diff.append(pool_diff)
                            pool_number = self.pools.index(pool)
                            message = ('pool %s: %s, web unixtime: %s, web time: %s, diff: %s seconds'
                                        % (pool_number, url, web_unixtime, web_time, pool_diff))
                            logger.info(message)

        message = "End fetching remote times."
        logger.info(message)

        message = self._('success')
        icon = "success"
        status = "success"
        return icon, status, message

    def wait_sleep(self):
        self.sleep_time_seconds = randint(sleep_time_minimum_seconds, sleep_time_maximum_seconds)
        sleep_time_minutes = self.sleep_time_seconds / 60

        message = (sdwdate_message_from_loop + " " + sdwdate._('sleeping') +
                  str(sleep_time_minutes) + sdwdate._('minutes'))

        stripped_message = sdwdate.strip_html(message)
        sdwdate.write_status(icon, message)

        if icon == 'success':
            #logger.info("wait_sleep: icon == success")
            logger.info(stripped_message)
        elif icon == 'busy':
            logger.error("wait_sleep: icon == busy")
            logger.error(stripped_message)
        elif icon == 'error':
            #logger.info("wait_sleep: icon == error")
            logger.error(stripped_message)
        else:
            logger.error("wait_sleep: icon == else")
            logger.error(stripped_message)

        n.notify("WATCHDOG=1")

        range_nanoseconds = 999999999
        nanoseconds = randint(0, range_nanoseconds)

        if self.sleep_time_seconds >= 10:
            f = open(sdwdate.sleep_long_file_path, 'w')
            f.close()

        self.unixtime_before_sleep = int(time.time())

        ## Using sh sleep in place of python's time.sleep(self.sleep_time_seconds).
        ## The latter uses the system clock for its inactive state time.
        ## It becomes utterly confused when sclockadj is running.
        sleep_cmd = "sleep" + " " + str(self.sleep_time_seconds) + "." + str(nanoseconds)
        message = "running command: " + sleep_cmd
        logger.info(message)
        self.sleep_process = Popen(sleep_cmd, shell=True)
        self.sleep_process.wait()

    def check_clock_skew(self):
        unixtime_after_sleep = int(time.time())
        time_delta = unixtime_after_sleep - self.unixtime_before_sleep
        time_passed = self.sleep_time_seconds - time_delta

        if time_passed > 2:
           time_no_unexpected_change = False
        elif time_passed < -2:
           time_no_unexpected_change = False
        else:
           time_no_unexpected_change = True

        if time_no_unexpected_change == True:
           message = "Slept for about " + str(time_delta) + " seconds."
           logger.info(message)
        else:
           message = "Clock got changed by something other than sdwdate. sleep_time_seconds: " + str(self.sleep_time_seconds) + " time_delta: " + str(time_delta) + " time_passed: " + str(time_passed)
           logger.warning(message)


if __name__ == "__main__":
    logger = logging.getLogger('sdwdate')
    logger.setLevel(logging.INFO)
    formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s", datefmt='%Y-%m-%d %H:%M:%S')
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)

    self_pid = os.getpid()
    pid_message = 'sdwdate started. PID: %s' % self_pid
    logger.info(pid_message)

    if os.geteuid() == 0:
        do_not_run_as_root_message = "Exit error... sdwdate should not be run as root!"
        logger.error(do_not_run_as_root_message)
        reason = "sdwdate should not be run as root."
        exit_code = 1
        sdwdate.exit_handler(exit_code, reason)

    sdwdate = Sdwdate()
    signal.signal(signal.SIGTERM, sdwdate.signal_sigterm_handler)

    proxy_message = ('Tor socks host: %s Tor socks port: %s'
                     % (sdwdate.proxy_ip, sdwdate.proxy_port))
    logger.info(proxy_message)

    loop_counter = 0
    loop_max = 10000
    retry_on_error_counter = 0

    while True:
        if loop_counter >= loop_max:
            loop_counter = 0
        loop_counter += 1

        msg = "Running sdwdate main loop. iteration: " + str(loop_counter) + " / " + str(loop_max)
        logger.info(msg)

        sdwdate.preparation()

        msg = "STATUS=Running sdwdate main loop. iteration: " + str(loop_counter) + " / " + str(loop_max)
        n.notify(msg)
        n.notify("WATCHDOG=1")

        ## use missing_ok=True in python 3.8
        if os.path.isfile(sdwdate.sleep_long_file_path):
            os.remove(sdwdate.sleep_long_file_path)

        sdwdate = Sdwdate()

        ## Debugging.
        #pool = Time_Source_Pool(0)
        #x = pool.allowed_failures()
        #print("main allowed_failures: " + str(x))
        #sys.exit(0)

        icon, status, sdwdate_message_from_loop = sdwdate.sdwdate_loop()
        n.notify("WATCHDOG=1")

        if status == 'success':
            sdwdate.build_median()
            sdwdate.add_or_subtract_nanoseconds()
            sdwdate.set_new_time()

            retry_on_error_counter = 0
            ## If we make the sleep period configurable one day, we need to
            ## advice the user to also adjust WatchdogSec= in sdwdate's systemd
            ## unit file.
            ## minimum sleep time: 60 minutes
            sleep_time_minimum_seconds = 60 * 60
            ## maximum sleep time: 180 minutes
            sleep_time_maximum_seconds = 180 * 60

        elif status == 'error':
            message = "retry_on_error_counter: " + str(retry_on_error_counter)
            logger.info(message)

            retry_on_error_counter += 1

            if retry_on_error_counter >= 3:
               ## minimum sleep time: 1 second multiplied with retry_on_error_counter
               sleep_time_minimum_seconds = 1 * retry_on_error_counter
               ## maximum sleep time: 5 seconds multiplied with retry_on_error_counter
               sleep_time_maximum_seconds = 5 * retry_on_error_counter
               if sleep_time_minimum_seconds >= 60 * 60:
                  sleep_time_minimum_seconds = 60 * 60
               if sleep_time_maximum_seconds >= 180 * 60:
                  sleep_time_maximum_seconds = 180 * 60
            else:
               sleep_time_minimum_seconds = 0
               sleep_time_maximum_seconds = 0

        sdwdate.wait_sleep()
        sdwdate.check_clock_skew()
        sdwdate.kill_sclockadj()
